import numpy as np

def compute_junge_ccn(r, N1=9e9, N2=2e6, r1=0.01e-6, r2=0.1e-6, sigma1=0.5, sigma2=0.7):
    """
    Вычисляет двухмодальное логнормальное распределение для ядер конденсации (CCN).
    Основано на уравнениях 5.29-5.31 из монографии.

    Args:
        r (np.ndarray): Массив радиусов [м], для которых вычисляется распределение.
        N1 (float): Общая числовая концентрация для моды 1 (малые ядра) [м⁻³].
        N2 (float): Общая числовая концентрация для моды 2 (крупные ядра) [м⁻³].
        r1 (float): Средний геометрический радиус для моды 1 [м].
        r2 (float): Средний геометрический радиус для моды 2 [м].
        sigma1 (float): Геометрическое стандартное отклонение для моды 1.
        sigma2 (float): Геометрическое стандартное отклонение для моды 2.

    Returns:
        np.ndarray: dN/d(log r), числовая концентрация на логарифмический интервал радиуса.
    """
    # Убедимся, что радиус положительный, чтобы избежать ошибок в логарифме
    r_safe = np.maximum(r, 1e-12)
    log_r = np.log(r_safe)
    log_r1 = np.log(r1)
    log_r2 = np.log(r2)
    
    # Мода 1 (малые ядра)
    # Формула для dN/d(log r)
    term1_exp = -0.5 * ((log_r - log_r1) / sigma1)**2
    f1 = (N1 / (sigma1 * np.sqrt(2 * np.pi))) * np.exp(term1_exp)
    
    # Мода 2 (крупные ядра)
    term2_exp = -0.5 * ((log_r - log_r2) / sigma2)**2
    f2 = (N2 / (sigma2 * np.sqrt(2 * np.pi))) * np.exp(term2_exp)
    
    return f1 + f2
